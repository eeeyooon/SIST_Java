package com.test.java.obj.stereo;

public class Ex50_abstract {

	public static void main(String[] args) {
		
		//Ex50_abstract.java
		
		/*
			
			1. 클래스
				-실체화를 한다. > 객체를 만든다.
				-구현된 멤버를 가진다. > 멤버 변수, 멤버 메소드(바디 O '{}')를 가진다.
				
			2. 인터페이스
				-실체화가 불가능하다. > 객체를 못 만든다.
				-추상 멤버를 가진다. > 추상 메소드 
				//자바는 추상메소드말고도 더 들어가지만 다른 언어들은 안들어감. 그래서 기본적으로는 못가진다고 생각해.(보편적인걸로 공부해)
				-클래스의 부모가 되어서 표준화 역할을 함. (사용법 강제 통일)  + 자격 부여
				
			3. 추상 클래스
				-클래스와 인터페이스의 중간.
				-실체화가 불가능함. > 객체를 못만든다.
				-구현된 멤버를 가진다. > 멤버 변수, 멤버 메소드(바디 O '{}')를 가진다.
				-추상 멤버를 가진다. > 추상 메소드 
				
		
		*/
		
		
		//Keyboard k1 = new Keyboard(); //error
										//이게되면 charge() 호출했을때 어쩔건데? > 그래서 인스턴스 자체를 인정 안해줌.
										//그럼 어따 써? > 얘도 클래스니까 상속할때 사용함 ^^
		
		
		K8 k = new K8();
		k.color = "white";	//구현멤버 사용
		k.info();			//구현멤버 사용
		k.charge();			//추상멤버 구현
		
		
	}//main
	
}//Ex50


//추상 클래스 언제써?
//-사용법도 정해주고싶은데(추상메소드) 일반변수/일반메소드도 물려주고싶어.
// 일부 같이 만들어진걸 물려주느냐 안물려주느냐가 추상 클래스와 인터페이스의 차이. >> 근데 의외로 추상 클래스가 더 안좋음 ㅋ

//인터페이스는 언제써? -> 사용법만 정해주고싶을때. 일반 변수/ 일반메소드는 알아서 정해;

//추상 클래스
abstract class Keyboard { //class 앞에 abstract 붙이면 됨.
	
	//구현멤버 가질 수 있음. (일반 멤버)
	private int price;
	public String color;
	
	public void info() {
		System.out.println(this.color);
		System.out.println(this.price);
	}

	
	//추상멤버 (추상 메소드)
	
	//void charge(); //error.
					 //인터페이스는 추상메소드밖에 올 수 없으니 다 생략해도 추상메소드로 받아들이지만 추상 클래스는 다 생략하면 추상메소드로 인지x
					 //추상 메소드는 abstract가 와야 추상메소드로 인정받음. (인터페이스에선 생략해도 ok)
	
	public abstract void charge();
	
	
	
}


class K8 extends Keyboard { 
	//extends임

	
	
	@Override
	public void charge() {	//구현 안하면 error남. -> 인터페이스랑 같음. but, 실제로 같진 않아. 
							//얜 추상 메소드만 물려준게 아니라 일반 멤버도 물려준거
							//>> main에서 확인해. K8이 Keyboard의 color도 사용가능
		
	} 
	
	
	
	
	
}





//사용빈도
//- 인터페이스 >>>>> 추상클래스
// 추상클래스는 -> 이 규칙도 지키고 반드시 이 부품을 가지고 만들어. >> 어떤 면에서는 편리하지만 어떤 면에서는 제약이 너무 심할 수도. > 복잡성 증가
//  		 => 다루기가 힘들어서 많이 안쓰는 것. (인터페이스도 벅차 ㅋ휴)
//			  + 추상클래스는 이정도만 보고, 인터페이스에 집중해. 인터페이스가 익숙해질때쯤 다시 추상클래스볼것.
// 인터페이스는 -> 이 규칙은 지키는 대신 나머지는 너 마음대로 해.














