package com.test.java; // 03.22

public class Ex29_String {

	public static void main(String[] args) {

		// Ex29_String.java
		// -문자열의 실체 (!)

		// 1. 메모리의 공간은 한번 할당되면 더 이상 늘리거나 줄일 수 없다.
		// 2. "문자열은 불변이다." (프로그래밍 세계에서 유명한 말)
		// 3. 문자열은 참조형이다. //길이가 늘 달라져서 참조형으로..


		// 자바 자료형 **
		// 1. 값형
		// - 값이 변경되어도 공간의 크기는 변화가 없음.
		// 2. 참조형
		// - 값이 변경되면 공간의 크기가 변함.


		//m1();
		m2();
		
		

	} //main

	private static void m2() {
		
		//String vs StringBuilder
		//- 둘다 문자열
		
		String s1 = "홍길동"; //문자열 리터럴 사용 ("")
		
		String s3 = new String("홍길동"); // 문자열의 원래 모습 (문자열만 특별하게 생략 허락해줌
		
		StringBuilder s2 = new StringBuilder("홍길동"); //참조형의 기본코드 (허락 못받음 ㅋ)
		
		//이 셋은 같은 애라고 생각해. (s1과 s2는 진짜 같은거임.) s3도 거의 같다~ -> 코드짜기 조금 불편한 애 정도.
		
		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s3);
		
		System.out.println(s1.length());
		System.out.println(s2.length());
		System.out.println(s3.length());
		
		//StringBuilder > 기존의 String에 비해 가지는 장점 > 수정 작업에 강함!! >> 그래서 씀
		
		//일반적인 문자열 작업엔 > String 사용 (조금 수정해도, 조금 덩치가 커도 ㄱㅊㄱㅊ)
		//하드한 수정 작업은 > StringBuilder 사용. (극한 수정작업은 꼭!)
		
		long begin = System.nanoTime();
		
		String txt1 = "홍길동";
		
		for (int i=0; i<100000; i++) {
			txt1 = txt1 + "."; //수정 작업
		}
		
		long end = System.nanoTime();
		System.out.println(txt1.length());
		System.out.println(end - begin + "ns"); //소요시간 2.0s
		
		
		begin = System.nanoTime();
		
		StringBuilder txt2 = new StringBuilder("홍길동");
		
		for (int i=0; i<100000; i++) {
			txt2.append("."); //덧붙이고 싶은 글자를 매개변수로 넣음. 
			//txt1. = txt1 + "."; 와 같은 문장
		}
		
		end = System.nanoTime();
		System.out.println(txt2.length());
		System.out.println(end - begin + "ns"); //소요시간 0.00209s 
												//=> 메모리 점유율이 낮아짐 > 가비자(Garbage) 발생 안함.
												// String보다 훨씬 빠름. 더 큰 값도 빠르게 출력함
	}

	private static void m1() {
		// -값형은 변수 그자체가 데이터를 저장함.
		int n1 = 10; // 4byte
		int n2 = 20; // 4byte


		n1 = 1000000000; // 여전히 4byte 변수에 10을 넣던 10억을 넣던 32자리의 1과 2의 조합일뿐..

		// ****모든 값형은 어떤 데이터를 넣더라도 공간의 크기가 불변이다!!!


		// -참조형은 스택에 실제 데이터가 아닌 실제 데이터의 참조 주소를 가지고 있음.
		// -Heap에 그 데이터가 저장되어 있음.
		// 글자하나당 2byte/ 글자 하나의 공간이 char하나
		String s1 = "홍길동"; // 6byte 주소지가 100
		String s2 = "아무개"; // 6byte

		System.out.println(s1); // 100번지

		s1 = "홍길동안녕하세요"; // -> 16byte가 필요한데 기존 공간은 6byte
							// >> 16byte짜리 상수를 새로 만들어 그 주소값(300)을 s1에 넣어놓음.
							// s1에 있는 주소값이 100에서 300으로 바뀜.
							// 한번 만들어진 문자열은 절대 바뀌지 않기때문에! 주소값을 변경하는 것!!

		System.out.println(s1); // 300번지 (주소값 변경을 통해 s1에서 출력되는 데이터를 바꿈)

		// 코드상의 모든 문자열 리터럴은 메모리(힙)에 새로 생성됨. 무조건.
		s1 = "참"; // 2byte -> 글자가 줄어들어도 문자열 상수(400번지)를 새로 만듦!

		System.out.println(s1); // 400번재ㅣ 문자열이 바뀐게 아니라 주소값이 바뀐 것!



		// 자료형 > int
		int a = 10; // 4byte
		int b = 20; // 4byte
		int c = 10000000; // 4byte

		// 자료형 > int[]
		int[] alist = new int[3]; // 12byte
		int[] blist = new int[5]; // 20byte
		int[] clist = new int[10]; // 40byte

		// 자료형 > String
		String t1 = "홍길동"; // 6byte
		String t2 = "홍"; // 2byte
		String t3 = "홍길동입니다."; // 14byte

		// 참조형들은 모두 실제 데이터는 Heap, 참조변수는 stack에 저장되도록 정해짐.

		String txt = "홍길동";
		txt = "아무개";


		// 이렇게 하는 이유는 ? > 효율적이기 때문.



		// a.
		String m1 = "홍길동"; // 6byte
		String m2 = "홍길동"; // 6byte
		String m3 = "홍길동"; // 6byte
		// b. 원래 필요한건 18byte인데 상수를 재사용하니 9byte만 쓸 수 있는 것.


		String w1 =
				"홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. ";
		// 대략 600byte라고 가정.


		String w2 =
				"홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. ";
		// 대략 600byte라고 가정.

		String w3 =
				"홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. 홍길동입니다. 안녕하세요. 저는 자바를 배우는 학생입니다. ";
		// 대략 600byte라고 가정.


		// b. 1800byte가 필요했는데 재사용함으로서 600byte로 줄일 수 있음.

		// a.크기도 큰데 동일한 데이터를 여러개를 반복해서 메모리에 넣으면 금방 소진될거라고 판단,
		// > 그래서 만들기전에 기존에 만들어진 상수 중에 똑같은게 있는지 먼저 확인,
		// 동일한 데이터가 Heap안에 존재한다면 재사용함.
		// >> 다만, 같은 지역에 한해서만 (같은 메소드내에서만)


		// c. 문자열은 불변이다!
		String z1 = "홍길동";
		String z2 = "홍길동";

		z1 = "홍길남";

		// 만약 "홍길남"이 따로 만들어진게 아니라 기존의 홍길동에서 수정된거라면,
		// z2의 값도 "홍길남"이 됨. 바꾸지도 않은 값이 바뀌어버리는 것. >> 이러면 안되니까 새로 만드는 겨.
		// z1의 주소값을 "홍길동"의 주소지에서 "홍길남"의 주소지로 바꿈. z2는 그대로 "홍길동"의 주소값을 가지고 있음.

		// 문자열을 대상하는 피해야 하는 행동
		// 1. 문자열의 잦은 수정 (하지않는게 이상적)
		// 2. 큰 문자열의 수정

		// 참조가 끊긴다 -> 더이상 아무 변수도 그 주소를 모른다. >> Garbage라고 부름. (메모리를 낭비하는 주원인)
		// Garbage collector가 주로 Heap을 돌면서 그런 Garbage를 제거함. (자유공간으로 만듦)

		String txt1 = "홍길동";

		for (int i = 0; i < 100; i++) {
			txt1 = txt1 + "님"; // 누적 -> 수정 > 100번 일어남.

		}

		System.out.println(txt1);
		System.out.println(txt1.length());

		txt1 = "홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다. 홍길동입니다"; // 커다란
																																																																																																																					// 데이터

		// 마지막에 '.'을 빼먹어서 추가하려면

		txt1 = txt1 + ". "; // 이렇게하면 커다란 데이터 하나가 또 생기는 것. (다른 하나는 커다란 Garabage가 됨)
							// 작업이 무거워짐.
	}
}


