package com.test.java.collection; //04.06

public class Ex65_Anonymous {

	public static void main(String[] args) {
		//Ex65_Anonymous.java
		//굳이 말하면 obj 수업이지만 주로 컬렉션에서 쓰기 때문에 컬렉션 패키지
	
	
		/*
	
			익명 객체, Anonymous Object
			- 익명 클래스, Anonymous Class
			- 이름없는 클래스(객체)
			- 반드시 인터페이스가 필요함. (자바 특성. 문법 한계)
			
	
	
	
		*/
		
		//요구사항] 인터페이스를 구현한 클래스의 객체 생성
		//1. 본인 타입으로 참조 변수 만들기
		
		BBB b1 = new BBB();
		b1.aaa();
		b1.bbb();
		System.out.println();
		
		//2. 부모 타입(부모가 인터페이스일때)으로 참조 변수 만들기 (부모가 인터페이스이면 인터페이스로 참조변수 생성)
		//-업캐스팅
		// 실무에선 무조건 2번 방식으로 사용 (설명은 나중에 할게)
		
		AAA b2 = new BBB();
		b2.aaa();
		//b2.bbb(); > 안보임(자식이 직접 만든 메소드니까 부모한텐 안보임) > 자식 클래스의 고유 멤버
		((BBB)b2).bbb(); //고유 멤버 접근이 필요하면 다운 캐스팅을 하여 접근하는 방법있긴함 (약간 번거로움)
		System.out.println();
		
		//3. 
		// 인터페이스는 객체를 못만들지만 만들 수 있는 방법 O
		// 인터페이스가 객체를 생성하지 못하는 이유 : 밑에꺼가 불가능하니까 행동 자체를 부정하기 위해서 생성조차 못하도록
		// b3.aaa(); 불가능 ( > 구현부 X 메소드니까) 
		
		//근데 인터페이스로 객체를 생성하재 
		// > AAA()뒤에 {}; 넣으면 돼. -> 그럼 에러 내용 바뀜 
		//> The type new AAA(){} must implement the inherited abstract method AAA.aaa()
		//부모의 추상 메소드를 만들지 않으면 나오는 에러와 같음. //오버라이드하면 에러 x
		
		//수업 녹화 11:30부터 12시 수업
		
		AAA b3 = new AAA() {
		//밑의 코드는 인터페이스를 상속받은 하위 자식 클래스임. (클래스명이 없는)
		//클래스의 정의부를 작성한 것 (부모가 시킨 메소드 구현) BBB의 구현 내용과 같음)
		//b3를 익명 객체라고 함.
			
			
			@Override
			public void aaa() {
				
				System.out.println("추상 메소드 구현"); //부모가 물려준 추상메소드 구현
				
			}
			
			
			//얘도 클래스니까 메소드 만들 수 있어? a.
			//b.익명 객체는 자신의 멤버를 만들지 않음 > 부모의 인터페이스 참조변수를 통해서 호출이 불가능하고
			//								   다운 캐스팅도 불가능하니까.
			// >> 부모의 추상메소드만 구현해도 역할 다함.
			//a. 
			//			public void ccc() {
//				System.out.println("자신만의 메소드 구현");
//			}
			
			
		};
		
		b3.aaa();
		System.out.println();
		
		
		//b2와 b3를 비교하면 돼
		//- 공통점: AAA 인터페이스를 구현한 클래스의 객체이다.
		b2.aaa();
		b3.aaa();
		// >> 둘다 구현 가능.
		
		//- 차이점 : b2 > 일반 클래스의 객체	> 다운 캐스팅 가능
		//		  : b3 > 익명 클래스의 객체 	> 다운 캐스팅 불가능 > 타입의 이름이 없어서
		//			(틀은 있는데 그 틀의 이름만 없을뿐) 
		((BBB)b2).bbb(); //다운캐스팅하면 가능
		//a. b3도 ccc호출하고 싶어 -> 얘도 AAA타입 버리고 다운캐스탱 해주면 되나?
		//근데 형변환 안돼 > 이름이 없으니까! >> 근데 얘는 원래 타입으로 돌려주려고 만든애가 아님(쓰임새가 달라)
		
		
		//c.
		
		//*** 모든 코드를 통틀어 단 1개의 객체가 필요한 경우 (다시 만들 일x)
		
		//객체를 만들 때 선행 작업
		//1. 클래스 선언 > 객체 N개 생성
		//2. 클래스 없이 > 객체 1개 생성 > 익명클래스
		
		//1회용 객체 생성 > 익명 클래스의 역할!!
		
		
	}//main
	
}//Ex65

//인터페이스는 객체 생성 x -> 자식한테 객체 생성 물려줘야함
interface AAA {
	void aaa();
}

class BBB implements AAA {
	
	@Override
	public void aaa() {
		System.out.println("추상 메소드 구현"); //오버라이드 형태로 추상 메소드 구현
	}
	
	//자식은 자신만의 메소드도 만들 수 있음.
	
	public void bbb() {
		System.out.println("자신만의 메소드 구현");
	}
	
}


//이게 바로 위 코드와 같은 것임. (대신 위 코드의 '클래스'가 없는 것과 마찬가지. 이름X)
/*
new AAA() {
	
	@Override
	public void aaa() {
		
	}
};
*/





